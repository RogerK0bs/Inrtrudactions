Структуры и классы																												16-17.01.2023
Для обращения к полям объкта можно использовать 
'.'		- оператор прямого доступа (point operator) - используется для доступа к полям объектам по имени объекта 
'->'	- оператор косвенного доступа (Arrow operator) - используется для доступа к полям объекта по адресу объекта


													Концепции ООП
ООП - базируется на 3 концепциях
1) Инкапсуляция (Encapsulation)
  Это сокрытие определнной части Класса от внешнего мира. Она реализуется модификаторами доступа и get/set методами
  Модификаторы доступа: (в языке C++ сущ всего 3 модиф доступа)
  1- private:	= закрытые поля, доступные только внутри class. Переменные члены класса обязательно должны быть private,
				  это защищает их от случайной перезаписи.
  2- public:	= это открытые поля, доступные из любого места программы. В public-секции обычно размещают методы.
  3- protected:	= это защищеные пол, доступны внутри нашего класса и его дочерних классов. Этот модификатор доступа используют только при
				  наследовании.
	Единственным отличием между class и struct явл то, что в структуре все поля по умолчанию О ткрыты, а в классе по умолчанию Закрыты.
	get/set - обеспечивают доступ извне к закрытым переменным в классе
	get (взять, получить) - позволяют получить(взять) значение переменной - открывают доступ на чтение к переменным членам класса
	set (назначить, установить, задать) - позволяют задать значение переменной в классе, или же открывают доступ к переменным
										  членам класса на запись
	Кроме того set-методы обеспечивают фильтрацию данных

																																18-19.01.2023
	GET-методы обязательно лдолжны быть const. CONST- называется метод, который не изменяет объект для которого вызывается. Для константного объекта могут быть вызванны 
											   константные методы  - double get_x()const {...} - 
	this -> - указатель на объект, для которого вызывается метод.
				Особые методы в классе
			В любом классе обязательно должны быть такие методы, как КОНСТРУКТОР, ДЕСТРУКТОР, ОПЕРАТОР ПРИСВАИНИЯ
			1. Constructor - это метод, который создает объект, а именно выделяет память под объект и инициализирует поля, при создании объекта 
			2. ~Destructor - это метод, который уничтожает объект, по истичении времени жизни. Время жизни объекта истекает, когда мы выходим за пределы области видимости,
			в которой объявлен этот объект. Например - при завершении функции в которой объявлен объект, или если счетчик цикла for считать объектом, то по завершении всех итераций 
			for'а, то для счетчика будет вызван деструктор.

			Конструктор и деструкток всегда называется так же как и класс, но перед ставится '~' - тильда.
			Конструкторы никогда не возвращают никаких значений и пеоед ними даже не пишеться void.
			Конструктор как и любая другая функция может принимать параметр, по этому как и любую другую Func его можно перегрузить. Это означает, то что в классе
			может быть сколько угодно конструкторов. Деструктор же никогда не принимает никаких параметров и перегрузить его нельзя, следовательно в любом классе может быть
			только 1 диструктор. Объекты могут создаваться по разному, но удаляются одинакого не зависимо от того как они были созданыю


																																19-20.01.20
			Конструкторы бывают с ПАРАМЕТРАМИ, БЕЗ ПАРАМЕТРОВ, ПО УМОЛЧАНИЮ, КОНСТРУКТОР КОПИРВОАНИЯ и КОНСТРУКТО ПЕРЕНОСА.
			ПО УМОЛЧАНИЮ - это конструктор, который может быть вызван без параметров. Это может быть конструктор не принимающий никаких параметров или же конструктор 
			каждый парметр которого имеет значение по умолчанию. Он выделяет память под объект и инициализирует все его поля значениями "по умолчанию".
			Так же вызывается не явно всякий раз, когда мы просто создаем объект и не знаем каким он будет.
			К примеру Point A; - Default constructor
			Конструктор по умолчанию может быть не явным, то есть если в классе нет ни одного конструктора, то компилятор сам добавит туда конструктор по умолчанию.
			Потому что без него не возможно создать объект. Такой не явный конструктор по умолчанию просто выделяет память под объект и инициализирует его поля значениями по умолчанию

			Чтобы определить каким будет объект, то нам нужен конструктор с параметрами
			Особое место занимает в параметризованных конструкциях - Конструктор с 1 параметром, который позволяет создать объект вот так Point C=4;
			Конструктор с параметрами по умолчанию  может быть универсальными и вызываться во всех случаях при создании объекта.
			Но иногда лучше перегрузить, чем использовать универсальный конструктор.

																																23-24.01.2023
			Конструктор копирования - это конструктор, который копирует объект, а именно создаваемый объект делает точной копией какого-то сущ объекта.
			Он всегда приниманет константную ссылку на объект нашего класса.
			Так же как и конструктор по умолчанию - конструктор копирования может быть не явным. То есть если мы его не написали, то компилятор сам его добавить.
			Конструктор копирования особенно важен в классе динамической памяти, он должен вызывать такое понятие как Deep Copy - или побитовое копирование,
			побайтовое копирование. А так же копирование по элементам.
			Не явный же конструктоо копирования может этого не сделать, и может выполнять Shallow copy - или ПОВЕРХНОСТНОЕ КОПИРОВАНИЕ.
			То есть копирование адреса памяти, вместа содержимого памяти.
			Если возникает необходимость скопировать сущ. объект, а именно сущ. объект сделать точной копией другого сущ.
			объекта для этих целей мы не сможем сделать конструктор копирвоания. 
			Потому что любой конструктор потому что любой констр. может быть вызвна для создания объектов. Конструктор не может быть вызван 2 раза.
			Для того чтобы скопировать сущ. объект вызывается оператор присваивания или же CopyAssigment. 
			Оператор присваивания делает тоже самое что и конструктор копирования,
			но после создания объекта
			Так же как и конструктор копирования - оператор принимает константную ссылку на объект и выполняет те же действия что и конструктор копирования,
			но уже для сущ объекта.
			Так же как и констурктор копирования - оператор присваивания критически важен,  если в классе используется динам. память и он так же может быть не явным
			Так же как и констурктор копирования - оператор присваивания долженн выполнять DeepCopy
																																	25-26.01.2023
			Перегрузка оператороа
			Мы много говорили как можно передать параметры в функцию (по значению, по указателю, по ссылке). Значение из функции может так же возвращаться как и приниматься - по значению, по указателю, по ссылке.
			И при возврате значения по значению - возвращаемое значение копируется на место вызова. А при возврате по указател, либо по ссылке - на место вызова копируется адрес возвращаемого значения.
			Если возвращаемое значение яв объектом, то вызывается конструктор копирования - он его копирует на место вызова. Для того чтобы скопировать адрес объекта - конструктор копирования не нужен.
			
			При возврате объекта по значению создается еще один объект, что приводить к дополнительным затратам ресурсов. И возвращая объект по адресу можно сэкономить ресурсы, но здесь нужно быть не много остожным.
			По скольку мы вернем ссылку или указатель на локальный объект, то он удалиться по завершении функции и на месте вызова иы увидим муссор. 
			Область видимости может сущ из нескольких выражений, но при этом одно выражение является областью видимости.

			Перегрузка операторов

			Она нужна для более удобной работы с рбъектами, чтобы над объектами можно было выполнять такие же действия как и над обычными переменными.
			Правила перегрузки операторов:
				a) Перегрузить можно только существующие операторы, не возможно создавать новые операторы 
						Например: + - перегружается
								  ++ - перегружается
								  * - перегружается
								  ** - НЕ перегружается
				b) Не все существующие операторы можно перегрузить
						Не перегружаются:
						?: - Conditional ternary
						:: - Scope operator (оператор разрешения видимости)
						. - оператор прямого доступа (Point operator)
						.* - Pointer to member selection
						# - Preprocessor directive
						## - Preprocessor concatenation
					
				c) Переопределить поведение операторов над встроенными типами невозможно
						Например не возможно заставить оператор '+', какие либо другие действия над типом данных int, кроме сложения
				d) Перегруженные операторы сохраняют приоритет

			Перегруженные операторы -- это самые обычные функции имя которых состоит из ключевого слова оператор и знака существующего оператора.
			Эти функции можно описать как в классе, так и за классом. Если оператор перегружен в классе, то он не является методом, 
			а значит может быть вызван только для какого-то объекта. Если оператор перегружен за классом, то он является самой обычной функцией, 
			а значит может быть вызван сам по себе. Если унарный оператор перегжуен внутри класса, то он никогда не принимает никаких параметров, 
			а единственным его операндом является объект для котого он вызывается. Но к этому объекту можно образщаться через this.
			Если унарный оператор перегружен за классом, то он в обязательном порядке принимает один и только один параметр - свлй операнд

			Если бинарный опертор перегружен внутри класса, то он в обязательном порядке принимает один и только один параметр - свой операнд справа,
			а ещё операндом слева является объект для которого он вызывается.
			Если унарный оператор перегружен за классом, то он в обязательном порядке принимает 2 параметра - свои операнды.
			При перегрузке операторов - всегда следует учитывать что некоторые операнды изменяют свои операторы, а некоторые нет. Те операторы, 
			которые изменяют свои операнды легче перегружать внутри класса, чтобы иметь прямой доступ к переменным члена класса. 
			Те операторы которые не изменяют свои операнды, удобнее перегружать за классом

																															26-27.01.2023
			Перегрузка операторов сравнения
			Операторы сравнения всегда возвращает тип данных bool. Их лучше перегружать за классом, потому что они не изменяют своих оперндов.



																															02-03.02.2023
																				Преобразование типов
			Существует явное и не явное преобразование типов. Явное - выполняет программист, а не явное - компилятор. Для того чтобы явно преобразовать значение в другой тип данных необходимо 
			желаемый тип данных написать в круглых скобках перед значениями. Или значение в круглых скобках после желаемого типа данных. 
			(type)value ; C Like notation (С-подобная форма записи)
			type(value) ; Functional notation (Функциональная флома записи)
			Не явные преобразования выполняет компилятор, а именно операторы. Все операторы C++ пытаются привести все значения в выражении к наибольшему типу данных, для того чтобы избежать потери данных
			или вернуть максимально точный результат. Например: ~Кроме присваиваний. 
			cout<<7/2<<endl; int 
			cout<<7./2<<endl; double
			
			Операторы присваивания всегда значение справа приводят к типу слева, если типы преобразуются. И не важно произойдет ли потеря данных или нет. Как явное и не явное преобразование.
			бывают от меньшего к большему так и наооборот. При чем последнее может привести к потере данных, при этом компилятор обычно выдает предупреждение
								Пребразование типов в ООП
			в ООП сущ 2 направления преобразования типов: 
					1. Преобразование других типов в наш
					2. Преобразование из нашего в др типы
			Для преобразование в объекты нашего класса. В классе должен быть конструктор с 1 параметром и оператор присваивания. При чём 2-ой без 1-ого не работает.

			Fraction A=5;// Conversion from other to class Single argument

			Fraction B;
			B=8; // Conversion from other to cla
			explicit - запрещает не явное преобразование. Разрешает только Явное.
			Для того чтобы объекты нашего класса преобразовывать в другие типы данных, в классе должны быть соответствуюзие операторы преобразования. Операторы преобразования (Type-cast operators) это
			самые обычные методы имя которых состоит обычного слова 
			operators type()const
			{
				conversion algoritm;
				return ...;
			}
			перегрузить можно только внтури класса. Операторы преобразования возвращают значение в обязательном порядке, хотя перед ними некогда не пишеться тип возвращаемого значения по скольку он
			является частью имени оператора. Для операторов преобразование примениме ключевое слово explicit, которое так же запрещает не явно преобразование.
			3. Assingment operator - это метод, который 
2) Наследование (Inheritance)
3) Полиморфизм (Polymorphism)
